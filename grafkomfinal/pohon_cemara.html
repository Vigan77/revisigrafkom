<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pohon Cemara WebGL</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #87CEEB;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            font-size: 12px;
        }
        #controls label {
            display: block;
            margin: 5px 0;
        }
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <div id="controls">
        <h3>Kontrol Pohon Cemara</h3>
        <label>
            Wind Strength: <input type="range" id="windStrength" min="0" max="2" step="0.1" value="0.5">
            <span id="windValue">0.5</span>
        </label>
        <label>
            Camera Distance: <input type="range" id="cameraDistance" min="5" max="100" step="1" value="30">
            <span id="camValue">30</span>
        </label>
        <label>
            Pine Trees: <input type="range" id="pineCount" min="0" max="50" step="1" value="3">
            <span id="pineValue">3</span>
        </label>
        <label>
            Maple Trees: <input type="range" id="mapleCount" min="0" max="50" step="1" value="2">
            <span id="mapleValue">2</span>
        </label>
        <label>
            Rounded Triangles: <input type="range" id="triangleCount" min="0" max="50" step="1" value="3">
            <span id="triangleValue">3</span>
        </label>
        <label>
            Triangle Height: <input type="range" id="triangleHeight" min="0.5" max="5" step="0.1" value="2.0">
            <span id="heightValue">2.0</span>
        </label>
        <label>
            Triangle Width X: <input type="range" id="triangleWidthX" min="0.5" max="4" step="0.1" value="1.5">
            <span id="widthXValue">1.5</span>
        </label>
        <label>
            Triangle Width Z: <input type="range" id="triangleWidthZ" min="0.5" max="4" step="0.1" value="1.5">
            <span id="widthZValue">1.5</span>
        </label>
        <button id="regenerate">Regenerate Objects</button>
    </div>

    <div id="info">
        FPS: <span id="fps">0</span> |
        Triangles: <span id="triangles">0</span>
    </div>

    <script>
        // ==================== UTILITY FUNCTIONS ====================

        class Mat4 {
            static create() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }

            static perspective(fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) * nf, -1,
                    0, 0, 2 * far * near * nf, 0
                ]);
            }

            static lookAt(eye, center, up) {
                const z = Vec3.normalize(Vec3.subtract(eye, center));
                const x = Vec3.normalize(Vec3.cross(up, z));
                const y = Vec3.cross(z, x);

                return new Float32Array([
                    x[0], y[0], z[0], 0,
                    x[1], y[1], z[1], 0,
                    x[2], y[2], z[2], 0,
                    -Vec3.dot(x, eye), -Vec3.dot(y, eye), -Vec3.dot(z, eye), 1
                ]);
            }

            static translate(x, y, z) {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    x, y, z, 1
                ]);
            }

            static rotateY(angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                return new Float32Array([
                    c, 0, s, 0,
                    0, 1, 0, 0,
                    -s, 0, c, 0,
                    0, 0, 0, 1
                ]);
            }

            static scale(sx, sy, sz) {
                return new Float32Array([
                    sx, 0, 0, 0,
                    0, sy, 0, 0,
                    0, 0, sz, 0,
                    0, 0, 0, 1
                ]);
            }

            static multiply(a, b) {
                const result = new Float32Array(16);
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        result[i * 4 + j] =
                            a[i * 4 + 0] * b[0 * 4 + j] +
                            a[i * 4 + 1] * b[1 * 4 + j] +
                            a[i * 4 + 2] * b[2 * 4 + j] +
                            a[i * 4 + 3] * b[3 * 4 + j];
                    }
                }
                return result;
            }
        }

        class Vec3 {
            static subtract(a, b) {
                return new Float32Array([a[0] - b[0], a[1] - b[1], a[2] - b[2]]);
            }

            static cross(a, b) {
                return new Float32Array([
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ]);
            }

            static dot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }

            static normalize(v) {
                const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                if (len > 0.00001) {
                    return new Float32Array([v[0] / len, v[1] / len, v[2] / len]);
                }
                return new Float32Array([0, 0, 0]);
            }
        }

        // ==================== SHADER SOURCES ====================

        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            attribute vec2 aTexCoord;
            attribute float aWindWeight; // Weight for wind animation
            attribute float aMaterialType; // 0 = trunk (bark), 1 = foliage (needles)

            // Instance attributes (for future GPU instancing)
            attribute vec3 aInstanceOffset;
            attribute float aInstanceScale;
            attribute float aInstancePhase;

            uniform mat4 uModelMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform float uTime;
            uniform vec3 uWindDirection;
            uniform float uWindStrength;
            uniform float uWindFrequency;

            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec2 vTexCoord;
            varying float vHeight;
            varying float vMaterialType;

            void main() {
                // Wind animation
                float windPhase = aInstancePhase + aPosition.y * 0.1;
                float windEffect = sin(uTime * uWindFrequency + windPhase) *
                                  cos(uTime * uWindFrequency * 0.7 + windPhase * 0.5);
                vec3 windOffset = uWindDirection * windEffect * uWindStrength * aWindWeight;

                vec3 position = aPosition + windOffset;

                // Apply transformations
                vec4 worldPos = uModelMatrix * vec4(position, 1.0);
                gl_Position = uProjectionMatrix * uViewMatrix * worldPos;

                vNormal = mat3(uModelMatrix) * aNormal;
                vPosition = worldPos.xyz;
                vTexCoord = aTexCoord;
                vHeight = aPosition.y;
                vMaterialType = aMaterialType;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;

            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec2 vTexCoord;
            varying float vHeight;
            varying float vMaterialType;

            uniform vec3 uLightDirection;
            uniform vec3 uLightColor;
            uniform vec3 uAmbientColor;
            uniform vec3 uCameraPosition;
            uniform vec3 uBaseColor;
            uniform float uRoughness;
            uniform float uTime;

            // Procedural bark texture
            float noise(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            float smoothNoise(vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                f = f * f * (3.0 - 2.0 * f);

                float a = noise(i);
                float b = noise(i + vec2(1.0, 0.0));
                float c = noise(i + vec2(0.0, 1.0));
                float d = noise(i + vec2(1.0, 1.0));

                return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
            }

            vec3 getBarkColor(vec2 uv) {
                // Base bark colors
                vec3 barkDark = vec3(0.25, 0.15, 0.10);   // Dark brown
                vec3 barkLight = vec3(0.45, 0.30, 0.20);  // Light brown

                // Vertical bark lines
                float verticalLines = smoothNoise(vec2(uv.x * 15.0, uv.y * 3.0));

                // Horizontal rings (wood texture)
                float rings = smoothNoise(vec2(uv.x * 8.0, uv.y * 30.0));

                // Rough bark detail
                float detail = smoothNoise(uv * 40.0) * 0.5 + smoothNoise(uv * 80.0) * 0.25;

                // Combine patterns
                float pattern = verticalLines * 0.5 + rings * 0.3 + detail * 0.2;

                return mix(barkDark, barkLight, pattern);
            }

            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDirection);

                // Material-based color
                vec3 baseColor;
                float roughness;

                if (vMaterialType < 0.5) {
                    // Trunk/Bark material
                    baseColor = getBarkColor(vTexCoord);
                    roughness = 0.9; // Very rough
                } else {
                    // Foliage material
                    baseColor = uBaseColor;
                    roughness = uRoughness;
                }

                // Diffuse lighting
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 diffuse = diff * uLightColor;

                // Simple specular (less for bark)
                vec3 viewDir = normalize(uCameraPosition - vPosition);
                vec3 halfDir = normalize(lightDir + viewDir);
                float specPower = vMaterialType < 0.5 ? 8.0 : 32.0;
                float specStrength = vMaterialType < 0.5 ? 0.05 : 0.3;
                float spec = pow(max(dot(normal, halfDir), 0.0), specPower / (roughness + 0.1));
                vec3 specular = spec * uLightColor * specStrength;

                // Ambient occlusion based on height
                float ao = 0.5 + 0.5 * (vHeight / 10.0);

                // Final color
                vec3 ambient = uAmbientColor * ao;
                vec3 color = baseColor * (ambient + diffuse) + specular;

                // Simple fog
                float fogDistance = length(vPosition - uCameraPosition);
                float fogAmount = smoothstep(40.0, 80.0, fogDistance);
                vec3 fogColor = vec3(0.53, 0.81, 0.92); // Sky blue
                color = mix(color, fogColor, fogAmount);

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // ==================== GEOMETRY GENERATION ====================

        class GeometryBuilder {
            // Create trunk (tapered cylinder)
            static createTrunk(height = 8, radiusBottom = 0.5, radiusTop = 0.3, segments = 12) {
                const vertices = [];
                const normals = [];
                const texCoords = [];
                const windWeights = [];
                const materialTypes = [];
                const indices = [];

                // Generate vertices with more height segments for better detail
                const heightSegments = 8;
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    const cosTheta = Math.cos(theta);
                    const sinTheta = Math.sin(theta);
                    const u = i / segments;

                    for (let j = 0; j <= heightSegments; j++) {
                        const t = j / heightSegments;
                        const y = t * height;
                        const radius = radiusBottom + (radiusTop - radiusBottom) * t;

                        // Add slight random variation for bark roughness
                        const barkVariation = Math.sin(theta * 7.0 + t * 13.0) * 0.02;
                        const r = radius + barkVariation;

                        vertices.push(
                            r * cosTheta,
                            y,
                            r * sinTheta
                        );

                        normals.push(cosTheta, 0, sinTheta);
                        texCoords.push(u, t * 2.0); // Stretch UV vertically
                        windWeights.push(t * t); // More wind effect at top
                        materialTypes.push(0.0); // 0 = bark/trunk
                    }
                }

                // Generate indices
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < heightSegments; j++) {
                        const base = i * (heightSegments + 1) + j;
                        const next = (i + 1) * (heightSegments + 1) + j;
                        indices.push(
                            base, base + 1, next,
                            base + 1, next + 1, next
                        );
                    }
                }

                return { vertices, normals, texCoords, windWeights, materialTypes, indices };
            }

            // Create conical branch layer (simplified LOD)
            static createConeLayer(radius, height, yOffset, segments = 8) {
                const vertices = [];
                const normals = [];
                const texCoords = [];
                const windWeights = [];
                const materialTypes = [];
                const indices = [];

                const baseIndex = 0;

                // Center top vertex
                vertices.push(0, yOffset + height, 0);
                normals.push(0, 1, 0);
                texCoords.push(0.5, 1);
                windWeights.push(1.0);
                materialTypes.push(1.0); // 1 = foliage

                // Bottom circle
                for (let i = 0; i <= segments; i++) {
                    const theta = (i / segments) * Math.PI * 2;
                    const x = radius * Math.cos(theta);
                    const z = radius * Math.sin(theta);

                    vertices.push(x, yOffset, z);

                    const nx = Math.cos(theta);
                    const nz = Math.sin(theta);
                    normals.push(nx, 0.5, nz);

                    texCoords.push(i / segments, 0);
                    windWeights.push(0.8);
                    materialTypes.push(1.0); // 1 = foliage
                }

                // Generate triangles
                for (let i = 0; i < segments; i++) {
                    indices.push(0, i + 2, i + 1);
                }

                return { vertices, normals, texCoords, windWeights, materialTypes, indices };
            }

            // Create needle cluster (multiple thin needles radiating outward)
            static createNeedleCluster(size = 0.5) {
                const vertices = [];
                const normals = [];
                const texCoords = [];
                const windWeights = [];
                const materialTypes = [];
                const indices = [];

                const needleCount = 8; // 8 needles per cluster
                const needleLength = size * 2;
                const needleWidth = size * 0.15;

                for (let i = 0; i < needleCount; i++) {
                    const angle = (i / needleCount) * Math.PI * 2;
                    const tilt = Math.random() * 0.3 + 0.5; // Random tilt outward

                    const dx = Math.cos(angle) * tilt;
                    const dz = Math.sin(angle) * tilt;

                    const baseIdx = vertices.length / 3;

                    // Create a thin quad for each needle
                    const perpX = -Math.sin(angle) * needleWidth;
                    const perpZ = Math.cos(angle) * needleWidth;

                    // Base of needle (4 vertices for slight width)
                    vertices.push(
                        perpX * 0.5, 0, perpZ * 0.5,
                        -perpX * 0.5, 0, -perpZ * 0.5,
                        dx * needleLength - perpX * 0.5, needleLength, dz * needleLength - perpZ * 0.5,
                        dx * needleLength + perpX * 0.5, needleLength, dz * needleLength + perpZ * 0.5
                    );

                    // Normals pointing outward and up
                    const nx = Math.cos(angle);
                    const nz = Math.sin(angle);
                    for (let j = 0; j < 4; j++) {
                        normals.push(nx, 0.3, nz);
                        materialTypes.push(1.0); // 1 = foliage
                    }

                    // Texture coordinates
                    texCoords.push(0, 0, 1, 0, 1, 1, 0, 1);

                    // Wind weights (tip moves more)
                    windWeights.push(0.2, 0.2, 1.0, 1.0);

                    // Indices for this needle (two triangles)
                    indices.push(
                        baseIdx + 0, baseIdx + 1, baseIdx + 2,
                        baseIdx + 0, baseIdx + 2, baseIdx + 3
                    );
                }

                return { vertices, normals, texCoords, windWeights, materialTypes, indices };
            }

            // Combine geometries
            static combineGeometries(geometries) {
                const vertices = [];
                const normals = [];
                const texCoords = [];
                const windWeights = [];
                const materialTypes = [];
                const indices = [];

                let vertexOffset = 0;

                for (const geom of geometries) {
                    vertices.push(...geom.vertices);
                    normals.push(...geom.normals);
                    texCoords.push(...geom.texCoords);
                    windWeights.push(...geom.windWeights);
                    materialTypes.push(...geom.materialTypes);

                    for (const idx of geom.indices) {
                        indices.push(idx + vertexOffset);
                    }

                    vertexOffset += geom.vertices.length / 3;
                }

                return { vertices, normals, texCoords, windWeights, materialTypes, indices };
            }
        }

        // ==================== TREE GENERATOR ====================

        class PineTree {
            constructor(detailLevel = 3) {
                this.geometry = null;
                this.detailLevel = detailLevel;
            }

            generate() {
                const geoms = [];

                // Determine detail settings
                let trunkSegments, layerCount, layerSegments, clusterCount;

                switch(this.detailLevel) {
                    case 1: // Low
                        trunkSegments = 8;
                        layerCount = 6;
                        layerSegments = 8;
                        clusterCount = 30;
                        break;
                    case 2: // Medium
                        trunkSegments = 12;
                        layerCount = 8;
                        layerSegments = 12;
                        clusterCount = 60;
                        break;
                    case 3: // High (default)
                    default:
                        trunkSegments = 16;
                        layerCount = 10;
                        layerSegments = 16;
                        clusterCount = 100;
                        break;
                }

                // Create trunk
                geoms.push(GeometryBuilder.createTrunk(8, 0.5, 0.3, trunkSegments));

                // Create cone layers
                for (let i = 0; i < layerCount; i++) {
                    const t = i / (layerCount - 1);
                    const radius = 3.5 - t * 2.5;
                    const height = 1.5 - t * 0.2;
                    const yOffset = 2 + i * 0.7;
                    geoms.push(GeometryBuilder.createConeLayer(radius, height, yOffset, layerSegments));
                }

                // Add needle clusters - distributed in spiral pattern
                for (let i = 0; i < clusterCount; i++) {
                    const t = i / clusterCount;
                    const cluster = GeometryBuilder.createNeedleCluster(0.25 + Math.random() * 0.15);

                    // Spiral distribution
                    const spiralTurns = 5;
                    const angle = t * Math.PI * 2 * spiralTurns + Math.random() * 0.3;
                    const heightFactor = Math.pow(t, 0.8); // More clusters at bottom
                    const yPos = 2 + heightFactor * (layerCount * 0.7);

                    // Radius decreases with height
                    const baseRadius = 3.0 - heightFactor * 2.2;
                    const radius = baseRadius + (Math.random() - 0.5) * 0.6;

                    // Offset cluster
                    for (let j = 0; j < cluster.vertices.length; j += 3) {
                        cluster.vertices[j] += Math.cos(angle) * radius;
                        cluster.vertices[j + 1] += yPos;
                        cluster.vertices[j + 2] += Math.sin(angle) * radius;
                    }
                    geoms.push(cluster);
                }

                this.geometry = GeometryBuilder.combineGeometries(geoms);
                return this.geometry;
            }
        }

        // ==================== ROUNDED TRIANGLE GENERATOR ====================
        // Implementasi Loop Subdivision yang benar untuk triangular pyramid

        class RoundedTriangle {
            constructor(subdivisionLevel = 4, height = 2.0, widthX = 1.5, widthZ = 1.5) {
                this.geometry = null;
                this.subdivisionLevel = subdivisionLevel;
                this.height = height;    // Tinggi pyramid (Y axis)
                this.widthX = widthX;    // Lebar base di sumbu X
                this.widthZ = widthZ;    // Lebar base di sumbu Z (kedalaman)
            }

            generate() {
                // Step 1: Create base tetrahedron (triangular pyramid)
                let mesh = this.createTetrahedron();

                // Step 2: Apply Loop subdivision
                for (let i = 0; i < this.subdivisionLevel; i++) {
                    mesh = this.loopSubdivide(mesh);
                }

                // Step 3: Calculate smooth normals
                this.calculateSmoothNormals(mesh);

                this.geometry = mesh;
                return this.geometry;
            }

            createTetrahedron() {
                // Tetrahedron dengan kontrol width di 2 arah (X dan Z)
                const h = this.height;   // Height (Y axis)
                const wx = this.widthX;  // Width X axis
                const wz = this.widthZ;  // Width Z axis (depth)

                // 4 vertices unik - base triangle dengan proporsi berbeda di X dan Z
                const positions = [
                    0, h, 0,                         // 0: top
                    wx, 0, 0,                        // 1: base corner 1 (positive X)
                    -wx/2, 0, wz * 0.866,           // 2: base corner 2 (negative X, positive Z)
                    -wx/2, 0, -wz * 0.866           // 3: base corner 3 (negative X, negative Z)
                ];

                // 4 triangular faces (indices harus unik per vertex, tidak shared)
                const indices = [
                    0, 1, 2,  // Front face
                    0, 2, 3,  // Left face
                    0, 3, 1,  // Right face
                    1, 3, 2   // Bottom face
                ];

                return {
                    positions: positions,
                    indices: indices
                };
            }

            loopSubdivide(mesh) {
                const oldPos = mesh.positions;
                const oldIndices = mesh.indices;
                const numOldVerts = oldPos.length / 3;

                // Build adjacency information
                const edges = new Map();      // edge -> [v1, v2, opposite1, opposite2]
                const vertexEdges = new Map(); // vertex -> [neighboring vertex indices]

                // Build edges and adjacency
                for (let i = 0; i < oldIndices.length; i += 3) {
                    const i0 = oldIndices[i];
                    const i1 = oldIndices[i + 1];
                    const i2 = oldIndices[i + 2];

                    // Add all 3 edges of this triangle
                    this.addEdge(edges, i0, i1, i2);
                    this.addEdge(edges, i1, i2, i0);
                    this.addEdge(edges, i2, i0, i1);

                    // Build vertex adjacency
                    this.addVertexNeighbor(vertexEdges, i0, i1);
                    this.addVertexNeighbor(vertexEdges, i0, i2);
                    this.addVertexNeighbor(vertexEdges, i1, i0);
                    this.addVertexNeighbor(vertexEdges, i1, i2);
                    this.addVertexNeighbor(vertexEdges, i2, i0);
                    this.addVertexNeighbor(vertexEdges, i2, i1);
                }

                const newPositions = [];
                const newIndices = [];

                // Step 1: Update OLD vertex positions (even vertices)
                for (let i = 0; i < numOldVerts; i++) {
                    const neighbors = vertexEdges.get(i) || [];
                    const n = neighbors.length;

                    if (n === 0) {
                        // Isolated vertex
                        newPositions.push(oldPos[i*3], oldPos[i*3+1], oldPos[i*3+2]);
                        continue;
                    }

                    // Loop subdivision weight formula
                    const cosVal = Math.cos(2.0 * Math.PI / n);
                    const beta = (1.0 / n) * (5.0/8.0 - Math.pow(3.0/8.0 + cosVal/4.0, 2));
                    const alpha = 1.0 - n * beta;

                    // Weighted average: alpha * originalPos + beta * sum(neighborPos)
                    let x = alpha * oldPos[i*3];
                    let y = alpha * oldPos[i*3 + 1];
                    let z = alpha * oldPos[i*3 + 2];

                    for (const nIdx of neighbors) {
                        x += beta * oldPos[nIdx*3];
                        y += beta * oldPos[nIdx*3 + 1];
                        z += beta * oldPos[nIdx*3 + 2];
                    }

                    newPositions.push(x, y, z);
                }

                // Step 2: Create NEW edge vertices (odd vertices)
                const edgeVertexMap = new Map(); // edge key -> new vertex index

                for (const [edgeKey, edgeData] of edges) {
                    const [v1, v2, opp1, opp2] = edgeData;

                    const A = [oldPos[v1*3], oldPos[v1*3+1], oldPos[v1*3+2]];
                    const B = [oldPos[v2*3], oldPos[v2*3+1], oldPos[v2*3+2]];

                    let x, y, z;

                    if (opp2 !== -1) {
                        // Interior edge: 3/8 * (A + B) + 1/8 * (C + D)
                        const C = [oldPos[opp1*3], oldPos[opp1*3+1], oldPos[opp1*3+2]];
                        const D = [oldPos[opp2*3], oldPos[opp2*3+1], oldPos[opp2*3+2]];

                        x = 0.375 * (A[0] + B[0]) + 0.125 * (C[0] + D[0]);
                        y = 0.375 * (A[1] + B[1]) + 0.125 * (C[1] + D[1]);
                        z = 0.375 * (A[2] + B[2]) + 0.125 * (C[2] + D[2]);
                    } else {
                        // Boundary edge: simple midpoint
                        x = 0.5 * (A[0] + B[0]);
                        y = 0.5 * (A[1] + B[1]);
                        z = 0.5 * (A[2] + B[2]);
                    }

                    const newIdx = numOldVerts + edgeVertexMap.size;
                    edgeVertexMap.set(edgeKey, newIdx);
                    newPositions.push(x, y, z);
                }

                // Step 3: Build new topology (4 triangles per old triangle)
                for (let i = 0; i < oldIndices.length; i += 3) {
                    const v0 = oldIndices[i];
                    const v1 = oldIndices[i + 1];
                    const v2 = oldIndices[i + 2];

                    // Get edge midpoint indices
                    const e01 = edgeVertexMap.get(this.edgeKey(v0, v1));
                    const e12 = edgeVertexMap.get(this.edgeKey(v1, v2));
                    const e20 = edgeVertexMap.get(this.edgeKey(v2, v0));

                    // 4 new triangles
                    newIndices.push(
                        v0, e01, e20,    // corner triangle 0
                        v1, e12, e01,    // corner triangle 1
                        v2, e20, e12,    // corner triangle 2
                        e01, e12, e20    // center triangle
                    );
                }

                return {
                    positions: newPositions,
                    indices: newIndices
                };
            }

            edgeKey(v1, v2) {
                return v1 < v2 ? `${v1}_${v2}` : `${v2}_${v1}`;
            }

            addEdge(edges, v1, v2, opposite) {
                const key = this.edgeKey(v1, v2);
                if (!edges.has(key)) {
                    edges.set(key, [v1, v2, opposite, -1]);
                } else {
                    edges.get(key)[3] = opposite; // second opposite vertex
                }
            }

            addVertexNeighbor(vertexEdges, v, neighbor) {
                if (!vertexEdges.has(v)) {
                    vertexEdges.set(v, []);
                }
                const neighbors = vertexEdges.get(v);
                if (!neighbors.includes(neighbor)) {
                    neighbors.push(neighbor);
                }
            }

            calculateSmoothNormals(mesh) {
                const pos = mesh.positions;
                const indices = mesh.indices;
                const numVerts = pos.length / 3;

                // Initialize normals
                const normals = new Array(pos.length).fill(0);

                // Accumulate face normals
                for (let i = 0; i < indices.length; i += 3) {
                    const i0 = indices[i];
                    const i1 = indices[i + 1];
                    const i2 = indices[i + 2];

                    // Get positions
                    const v0 = [pos[i0*3], pos[i0*3+1], pos[i0*3+2]];
                    const v1 = [pos[i1*3], pos[i1*3+1], pos[i1*3+2]];
                    const v2 = [pos[i2*3], pos[i2*3+1], pos[i2*3+2]];

                    // Compute face normal
                    const e1 = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
                    const e2 = [v2[0]-v0[0], v2[1]-v0[1], v2[2]-v0[2]];

                    const nx = e1[1]*e2[2] - e1[2]*e2[1];
                    const ny = e1[2]*e2[0] - e1[0]*e2[2];
                    const nz = e1[0]*e2[1] - e1[1]*e2[0];

                    // Add to each vertex
                    normals[i0*3] += nx; normals[i0*3+1] += ny; normals[i0*3+2] += nz;
                    normals[i1*3] += nx; normals[i1*3+1] += ny; normals[i1*3+2] += nz;
                    normals[i2*3] += nx; normals[i2*3+1] += ny; normals[i2*3+2] += nz;
                }

                // Normalize
                for (let i = 0; i < numVerts; i++) {
                    const x = normals[i*3];
                    const y = normals[i*3+1];
                    const z = normals[i*3+2];
                    const len = Math.sqrt(x*x + y*y + z*z);

                    if (len > 0.00001) {
                        normals[i*3] = x / len;
                        normals[i*3+1] = y / len;
                        normals[i*3+2] = z / len;
                    }
                }

                // Add to mesh with additional attributes for rendering
                mesh.normals = normals;
                mesh.texCoords = new Array(numVerts * 2).fill(0.5);
                mesh.windWeights = new Array(numVerts).fill(0.3);
                mesh.materialTypes = new Array(numVerts).fill(1.0);

                // Convert to expected format
                mesh.vertices = mesh.positions;
                delete mesh.positions;
            }
        }

        // ==================== MAPLE TREE GENERATOR ====================

        class MapleTree {
            constructor(detailLevel = 3) {
                this.geometry = null;
                this.detailLevel = detailLevel;
            }

            generate() {
                const geoms = [];

                // Determine detail settings
                let trunkSegments, branchCount, leafClusters;

                switch(this.detailLevel) {
                    case 1: // Low
                        trunkSegments = 8;
                        branchCount = 4;
                        leafClusters = 100;
                        break;
                    case 2: // Medium
                        trunkSegments = 12;
                        branchCount = 6;
                        leafClusters = 200;
                        break;
                    case 3: // High (default)
                    default:
                        trunkSegments = 16;
                        branchCount = 10;
                        leafClusters = 400; // Massively increased for dense foliage
                        break;
                }

                // Create trunk - taller and thinner than pine
                geoms.push(GeometryBuilder.createTrunk(7, 0.4, 0.25, trunkSegments));

                // Create main branches spreading outward
                for (let i = 0; i < branchCount; i++) {
                    const angle = (i / branchCount) * Math.PI * 2;
                    const heightStart = 2 + Math.random() * 2;
                    const branch = this.createBranch(angle, heightStart, 0.2, 0.05);
                    geoms.push(branch);
                }

                // Create spherical foliage clusters (maple crown is round/spreading)
                // Use multiple layers for better coverage
                for (let i = 0; i < leafClusters; i++) {
                    const cluster = GeometryBuilder.createMapleLeafCluster(0.4 + Math.random() * 0.3);

                    // Multi-layer spherical distribution for dense round crown
                    const t = i / leafClusters;

                    // Use fibonacci sphere for better distribution
                    const goldenRatio = (1 + Math.sqrt(5)) / 2;
                    const phi = Math.acos(1 - 2 * t);
                    const theta = 2 * Math.PI * i / goldenRatio;

                    // Crown center and size - larger crown
                    const crownCenterY = 5.5;
                    const crownRadius = 3.5 + Math.random() * 1.2;

                    // Add some noise for natural distribution
                    const noise = (Math.random() - 0.5) * 0.5;
                    const r = crownRadius + noise;

                    const x = r * Math.sin(phi) * Math.cos(theta);
                    const y = crownCenterY + r * Math.cos(phi) * 0.6; // Flatten vertically more
                    const z = r * Math.sin(phi) * Math.sin(theta);

                    // Offset cluster
                    for (let j = 0; j < cluster.vertices.length; j += 3) {
                        cluster.vertices[j] += x;
                        cluster.vertices[j + 1] += y;
                        cluster.vertices[j + 2] += z;
                    }
                    geoms.push(cluster);
                }

                this.geometry = GeometryBuilder.combineGeometries(geoms);
                return this.geometry;
            }

            createBranch(angle, yStart, radiusStart, radiusEnd) {
                const vertices = [];
                const normals = [];
                const texCoords = [];
                const windWeights = [];
                const materialTypes = [];
                const indices = [];

                const segments = 6;
                const branchLength = 2.5 + Math.random() * 0.5;
                const upwardAngle = 0.3 + Math.random() * 0.3; // Branch angles upward

                // Branch extends outward and upward
                const dirX = Math.cos(angle);
                const dirZ = Math.sin(angle);

                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const radius = radiusStart + (radiusEnd - radiusStart) * t;

                    // Position along branch
                    const dist = t * branchLength;
                    const x = dirX * dist;
                    const y = yStart + dist * Math.tan(upwardAngle);
                    const z = dirZ * dist;

                    // Create ring of vertices
                    const ringSegments = 6;
                    for (let j = 0; j <= ringSegments; j++) {
                        const theta = (j / ringSegments) * Math.PI * 2;
                        const cx = Math.cos(theta) * radius;
                        const cy = Math.sin(theta) * radius;

                        // Rotate around branch direction
                        vertices.push(
                            x + cx * Math.cos(angle) - cy * Math.sin(angle),
                            y + cy,
                            z + cx * Math.sin(angle) + cy * Math.cos(angle)
                        );

                        normals.push(Math.cos(theta), Math.sin(theta), 0);
                        texCoords.push(j / ringSegments, t);
                        windWeights.push(t * t);
                        materialTypes.push(0.0); // Bark
                    }
                }

                // Create indices
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < 6; j++) {
                        const base = i * 7 + j;
                        const next = base + 7;
                        indices.push(base, next, base + 1);
                        indices.push(base + 1, next, next + 1);
                    }
                }

                return { vertices, normals, texCoords, windWeights, materialTypes, indices };
            }
        }

        // Add maple leaf cluster to GeometryBuilder
        GeometryBuilder.createMapleLeafCluster = function(size = 0.5) {
            const vertices = [];
            const normals = [];
            const texCoords = [];
            const windWeights = [];
            const materialTypes = [];
            const indices = [];

            // Massively increase leaves per cluster for dense foliage
            const leafCount = 12; // Increased from 5 to 12

            for (let i = 0; i < leafCount; i++) {
                const angle = (i / leafCount) * Math.PI * 2 + Math.random() * 0.8;
                const tilt = Math.random() * 0.6 + 0.4;
                const elevation = (Math.random() - 0.5) * 0.4; // Vary vertical position

                const baseIdx = vertices.length / 3;

                // Create maple leaf shape - larger and more varied
                const leafWidth = size * (1.0 + Math.random() * 0.5);
                const leafHeight = size * (1.2 + Math.random() * 0.6);

                // Position leaf in 3D space around cluster center
                const dx = Math.cos(angle) * tilt * 0.4;
                const dy = elevation;
                const dz = Math.sin(angle) * tilt * 0.4;

                // Create leaf quad with slight rotation
                const rotAngle = Math.random() * Math.PI * 0.3;
                const cosRot = Math.cos(rotAngle);
                const sinRot = Math.sin(rotAngle);

                // 4 corners of leaf
                const corners = [
                    [-leafWidth * 0.5, -leafHeight * 0.2],
                    [leafWidth * 0.5, -leafHeight * 0.2],
                    [leafWidth * 0.5, leafHeight * 0.8],
                    [-leafWidth * 0.5, leafHeight * 0.8]
                ];

                for (let c of corners) {
                    const rx = c[0] * cosRot - c[1] * sinRot;
                    const ry = c[0] * sinRot + c[1] * cosRot;
                    vertices.push(dx + rx, dy + ry, dz);
                }

                // Normals pointing up and slightly outward
                const nx = Math.cos(angle) * 0.3;
                const nz = Math.sin(angle) * 0.3;
                for (let j = 0; j < 4; j++) {
                    normals.push(nx, 0.85, nz);
                    materialTypes.push(1.0); // Foliage
                }

                texCoords.push(0, 0, 1, 0, 1, 1, 0, 1);

                // Wind weights - leaves flutter more
                const windWeight = 0.6 + Math.random() * 0.4;
                windWeights.push(windWeight * 0.5, windWeight * 0.5, windWeight, windWeight);

                indices.push(
                    baseIdx, baseIdx + 1, baseIdx + 2,
                    baseIdx, baseIdx + 2, baseIdx + 3
                );
            }

            return { vertices, normals, texCoords, windWeights, materialTypes, indices };
        };

        // ==================== WEBGL SETUP ====================

        class WebGLApp {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

                if (!this.gl) {
                    alert('WebGL tidak didukung di browser ini!');
                    throw new Error('WebGL not supported');
                }

                this.shaderProgram = null;
                this.trees = [];
                this.camera = {
                    position: [0, 5, 30],
                    target: [0, 5, 0],
                    up: [0, 1, 0],
                    distance: 30,
                    angle: 0
                };

                this.windStrength = 0.5;
                this.time = 0;
                this.frameCount = 0;
                this.lastFPSUpdate = 0;

                this.init();
            }

            init() {
                const gl = this.gl;

                // Setup WebGL state
                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE); // Disable culling so leaves are visible from both sides
                gl.clearColor(0.53, 0.81, 0.92, 1.0); // Sky blue

                // Compile shaders
                this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);

                // Resize canvas
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                // Create trees and objects
                this.regenerateTrees(3, 2, 3, 2.0, 1.5, 1.5); // 3 pine, 2 maple, 3 rounded triangles (height=2.0, widthX=1.5, widthZ=1.5)
            }

            createShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            createShaderProgram(vsSource, fsSource) {
                const gl = this.gl;
                const vertexShader = this.createShader(gl.VERTEX_SHADER, vsSource);
                const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fsSource);

                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program link error:', gl.getProgramInfoLog(program));
                    return null;
                }

                return program;
            }

            regenerateTrees(pineCount, mapleCount, triangleCount = 0, triangleHeight = 2.0, triangleWidthX = 1.5, triangleWidthZ = 1.5) {
                this.trees = [];
                const totalCount = pineCount + mapleCount + triangleCount;

                // Create pine trees
                for (let i = 0; i < pineCount; i++) {
                    const tree = new PineTree(3); // Always use high detail
                    tree.generate();
                    tree.treeType = 'pine';

                    // Random position
                    const angle = (i / totalCount) * Math.PI * 2 + Math.random() * 0.5;
                    const distance = 5 + Math.random() * 15;

                    tree.position = [
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    ];
                    tree.scale = 0.8 + Math.random() * 0.4;
                    tree.rotation = Math.random() * Math.PI * 2;
                    tree.phase = Math.random() * Math.PI * 2;

                    // Create buffers
                    tree.buffers = this.createBuffersForGeometry(tree.geometry);

                    this.trees.push(tree);
                }

                // Create maple trees
                for (let i = 0; i < mapleCount; i++) {
                    const tree = new MapleTree(3); // Always use high detail
                    tree.generate();
                    tree.treeType = 'maple';

                    // 3 color variations: green (33%), orange autumn (33%), deep red autumn (33%)
                    const colorRand = Math.random();
                    if (colorRand < 0.33) {
                        tree.leafColor = 'green'; // Summer
                    } else if (colorRand < 0.66) {
                        tree.leafColor = 'orange'; // Early autumn
                    } else {
                        tree.leafColor = 'red'; // Late autumn - deep red/burgundy
                    }

                    // Random position
                    const angle = ((pineCount + i) / totalCount) * Math.PI * 2 + Math.random() * 0.5;
                    const distance = 5 + Math.random() * 15;

                    tree.position = [
                        Math.cos(angle) * distance,
                        0,
                        Math.sin(angle) * distance
                    ];
                    tree.scale = 0.9 + Math.random() * 0.3;
                    tree.rotation = Math.random() * Math.PI * 2;
                    tree.phase = Math.random() * Math.PI * 2;

                    // Create buffers
                    tree.buffers = this.createBuffersForGeometry(tree.geometry);

                    this.trees.push(tree);
                }

                // Create rounded triangles
                for (let i = 0; i < triangleCount; i++) {
                    // Gunakan parameter dari user dengan width X dan Z terpisah
                    const triangle = new RoundedTriangle(4, triangleHeight, triangleWidthX, triangleWidthZ);
                    triangle.generate();
                    triangle.treeType = 'roundedTriangle';

                    // Store dimensions for info
                    triangle.heightParam = triangleHeight;
                    triangle.widthXParam = triangleWidthX;
                    triangle.widthZParam = triangleWidthZ;

                    // Random color for rounded triangles (orange/yellow/purple variations)
                    const colorRand = Math.random();
                    if (colorRand < 0.33) {
                        triangle.objectColor = 'orange';
                    } else if (colorRand < 0.66) {
                        triangle.objectColor = 'purple';
                    } else {
                        triangle.objectColor = 'yellow';
                    }

                    // Random position
                    const angle = ((pineCount + mapleCount + i) / totalCount) * Math.PI * 2 + Math.random() * 0.5;
                    const distance = 5 + Math.random() * 15;

                    triangle.position = [
                        Math.cos(angle) * distance,
                        0, // Ground level
                        Math.sin(angle) * distance
                    ];
                    triangle.scale = 0.8 + Math.random() * 0.4; // Smaller scale since we have size variation
                    triangle.rotation = Math.random() * Math.PI * 2;
                    triangle.phase = Math.random() * Math.PI * 2;

                    // Create buffers
                    triangle.buffers = this.createBuffersForGeometry(triangle.geometry);

                    this.trees.push(triangle);
                }
            }

            createBuffersForGeometry(geometry) {
                const gl = this.gl;

                return {
                    position: this.createBuffer(new Float32Array(geometry.vertices)),
                    normal: this.createBuffer(new Float32Array(geometry.normals)),
                    texCoord: this.createBuffer(new Float32Array(geometry.texCoords)),
                    windWeight: this.createBuffer(new Float32Array(geometry.windWeights)),
                    materialType: this.createBuffer(new Float32Array(geometry.materialTypes)),
                    indices: this.createIndexBuffer(new Uint16Array(geometry.indices)),
                    indexCount: geometry.indices.length
                };
            }

            createBuffer(data) {
                const gl = this.gl;
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
                return buffer;
            }

            createIndexBuffer(data) {
                const gl = this.gl;
                const buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
                return buffer;
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
            }

            render() {
                const gl = this.gl;
                this.time += 0.016;

                // Update camera rotation
                this.camera.angle += 0.002;
                this.camera.position[0] = Math.sin(this.camera.angle) * this.camera.distance;
                this.camera.position[2] = Math.cos(this.camera.angle) * this.camera.distance;

                // Clear
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // Use program
                gl.useProgram(this.shaderProgram);

                // Setup matrices
                const projectionMatrix = Mat4.perspective(
                    Math.PI / 4,
                    this.canvas.width / this.canvas.height,
                    0.1,
                    100.0
                );

                const viewMatrix = Mat4.lookAt(
                    this.camera.position,
                    this.camera.target,
                    this.camera.up
                );

                // Set uniforms
                const uProjectionMatrix = gl.getUniformLocation(this.shaderProgram, 'uProjectionMatrix');
                const uViewMatrix = gl.getUniformLocation(this.shaderProgram, 'uViewMatrix');
                const uModelMatrix = gl.getUniformLocation(this.shaderProgram, 'uModelMatrix');
                const uTime = gl.getUniformLocation(this.shaderProgram, 'uTime');
                const uWindDirection = gl.getUniformLocation(this.shaderProgram, 'uWindDirection');
                const uWindStrength = gl.getUniformLocation(this.shaderProgram, 'uWindStrength');
                const uWindFrequency = gl.getUniformLocation(this.shaderProgram, 'uWindFrequency');
                const uLightDirection = gl.getUniformLocation(this.shaderProgram, 'uLightDirection');
                const uLightColor = gl.getUniformLocation(this.shaderProgram, 'uLightColor');
                const uAmbientColor = gl.getUniformLocation(this.shaderProgram, 'uAmbientColor');
                const uCameraPosition = gl.getUniformLocation(this.shaderProgram, 'uCameraPosition');
                const uBaseColor = gl.getUniformLocation(this.shaderProgram, 'uBaseColor');
                const uRoughness = gl.getUniformLocation(this.shaderProgram, 'uRoughness');

                gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix);
                gl.uniform1f(uTime, this.time);
                gl.uniform3f(uWindDirection, 1.0, 0.0, 0.2);
                gl.uniform1f(uWindStrength, this.windStrength);
                gl.uniform1f(uWindFrequency, 2.0);
                gl.uniform3f(uLightDirection, -0.3, 0.8, 0.5);
                gl.uniform3f(uLightColor, 1.0, 0.95, 0.8);
                gl.uniform3f(uAmbientColor, 0.3, 0.35, 0.4);
                gl.uniform3f(uCameraPosition, ...this.camera.position);
                gl.uniform1f(uRoughness, 0.8);

                // Render trees
                let totalTriangles = 0;

                for (const tree of this.trees) {
                    const buffers = tree.buffers;

                    // Model matrix
                    let modelMatrix = Mat4.translate(tree.position[0], tree.position[1], tree.position[2]);
                    modelMatrix = Mat4.multiply(modelMatrix, Mat4.rotateY(tree.rotation));
                    modelMatrix = Mat4.multiply(modelMatrix, Mat4.scale(tree.scale, tree.scale, tree.scale));

                    gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);

                    // Tree color variation - different colors for different tree types
                    let r, g, b;
                    if (tree.treeType === 'maple') {
                        const variation = Math.sin(tree.phase) * 0.06;
                        const rand = Math.sin(tree.phase * 2.3) * 0.08; // Color variety

                        if (tree.leafColor === 'green') {
                            // Summer maple - lighter, brighter green
                            r = 0.2 + variation;
                            g = 0.6 + variation;
                            b = 0.2 + variation * 0.5;
                        } else if (tree.leafColor === 'orange') {
                            // Early autumn maple - orange/yellow mix
                            r = 0.9 + variation + rand;
                            g = 0.45 + variation * 0.6 + rand * 0.3;
                            b = 0.12 + variation * 0.3;
                        } else {
                            // Late autumn maple - deep red/burgundy/crimson
                            // Dark reddish-brown with hints of orange
                            r = 0.65 + variation + rand * 0.5; // Deep red
                            g = 0.15 + variation * 0.4; // Low green for darkness
                            b = 0.12 + variation * 0.3; // Slight brown undertone
                        }
                    } else if (tree.treeType === 'roundedTriangle') {
                        // Rounded triangle colors - vibrant and distinct
                        const variation = Math.sin(tree.phase + this.time * 0.5) * 0.1;

                        if (tree.objectColor === 'orange') {
                            r = 0.95 + variation;
                            g = 0.50 + variation;
                            b = 0.10;
                        } else if (tree.objectColor === 'purple') {
                            r = 0.70 + variation;
                            g = 0.20;
                            b = 0.80 + variation;
                        } else { // yellow
                            r = 0.95 + variation;
                            g = 0.90 + variation;
                            b = 0.20;
                        }
                    } else {
                        // Deeper green for pine
                        const greenVariation = Math.sin(tree.phase) * 0.03;
                        r = 0.1 + greenVariation;
                        g = 0.35 + greenVariation;
                        b = 0.15 + greenVariation * 0.5;
                    }
                    gl.uniform3f(uBaseColor, r, g, b);

                    // Bind attributes
                    const aPosition = gl.getAttribLocation(this.shaderProgram, 'aPosition');
                    const aNormal = gl.getAttribLocation(this.shaderProgram, 'aNormal');
                    const aTexCoord = gl.getAttribLocation(this.shaderProgram, 'aTexCoord');
                    const aWindWeight = gl.getAttribLocation(this.shaderProgram, 'aWindWeight');
                    const aMaterialType = gl.getAttribLocation(this.shaderProgram, 'aMaterialType');
                    const aInstanceOffset = gl.getAttribLocation(this.shaderProgram, 'aInstanceOffset');
                    const aInstanceScale = gl.getAttribLocation(this.shaderProgram, 'aInstanceScale');
                    const aInstancePhase = gl.getAttribLocation(this.shaderProgram, 'aInstancePhase');

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                    gl.enableVertexAttribArray(aPosition);
                    gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normal);
                    gl.enableVertexAttribArray(aNormal);
                    gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.texCoord);
                    gl.enableVertexAttribArray(aTexCoord);
                    gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.windWeight);
                    gl.enableVertexAttribArray(aWindWeight);
                    gl.vertexAttribPointer(aWindWeight, 1, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.materialType);
                    gl.enableVertexAttribArray(aMaterialType);
                    gl.vertexAttribPointer(aMaterialType, 1, gl.FLOAT, false, 0, 0);

                    // Set instance attributes to default values
                    if (aInstanceOffset >= 0) {
                        gl.disableVertexAttribArray(aInstanceOffset);
                        gl.vertexAttrib3f(aInstanceOffset, 0, 0, 0);
                    }
                    if (aInstanceScale >= 0) {
                        gl.disableVertexAttribArray(aInstanceScale);
                        gl.vertexAttrib1f(aInstanceScale, 1.0);
                    }
                    if (aInstancePhase >= 0) {
                        gl.disableVertexAttribArray(aInstancePhase);
                        gl.vertexAttrib1f(aInstancePhase, tree.phase);
                    }

                    // Draw
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
                    gl.drawElements(gl.TRIANGLES, buffers.indexCount, gl.UNSIGNED_SHORT, 0);

                    totalTriangles += buffers.indexCount / 3;
                }

                // Update stats
                this.updateStats(totalTriangles);

                requestAnimationFrame(() => this.render());
            }

            updateStats(triangles) {
                this.frameCount++;
                const now = performance.now();

                if (now - this.lastFPSUpdate > 1000) {
                    const fps = Math.round(this.frameCount * 1000 / (now - this.lastFPSUpdate));
                    document.getElementById('fps').textContent = fps;
                    this.frameCount = 0;
                    this.lastFPSUpdate = now;
                }

                document.getElementById('triangles').textContent = Math.round(triangles);
            }
        }

        // ==================== MAIN ====================

        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('glCanvas');
            const app = new WebGLApp(canvas);

            // Controls
            document.getElementById('windStrength').addEventListener('input', (e) => {
                app.windStrength = parseFloat(e.target.value);
                document.getElementById('windValue').textContent = e.target.value;
            });

            document.getElementById('cameraDistance').addEventListener('input', (e) => {
                app.camera.distance = parseFloat(e.target.value);
                document.getElementById('camValue').textContent = e.target.value;
            });

            document.getElementById('pineCount').addEventListener('input', (e) => {
                const count = parseInt(e.target.value);
                document.getElementById('pineValue').textContent = count;
            });

            document.getElementById('mapleCount').addEventListener('input', (e) => {
                const count = parseInt(e.target.value);
                document.getElementById('mapleValue').textContent = count;
            });

            document.getElementById('triangleCount').addEventListener('input', (e) => {
                const count = parseInt(e.target.value);
                document.getElementById('triangleValue').textContent = count;
            });

            document.getElementById('triangleHeight').addEventListener('input', (e) => {
                const height = parseFloat(e.target.value);
                document.getElementById('heightValue').textContent = height.toFixed(1);
            });

            document.getElementById('triangleWidthX').addEventListener('input', (e) => {
                const width = parseFloat(e.target.value);
                document.getElementById('widthXValue').textContent = width.toFixed(1);
            });

            document.getElementById('triangleWidthZ').addEventListener('input', (e) => {
                const width = parseFloat(e.target.value);
                document.getElementById('widthZValue').textContent = width.toFixed(1);
            });

            document.getElementById('regenerate').addEventListener('click', () => {
                const pineCount = parseInt(document.getElementById('pineCount').value);
                const mapleCount = parseInt(document.getElementById('mapleCount').value);
                const triangleCount = parseInt(document.getElementById('triangleCount').value);
                const triangleHeight = parseFloat(document.getElementById('triangleHeight').value);
                const triangleWidthX = parseFloat(document.getElementById('triangleWidthX').value);
                const triangleWidthZ = parseFloat(document.getElementById('triangleWidthZ').value);
                app.regenerateTrees(pineCount, mapleCount, triangleCount, triangleHeight, triangleWidthX, triangleWidthZ);
            });

            // Start rendering
            app.render();
        });
    </script>
</body>
</html>
